\chapter{Deseño e implementación}
\minitoc
% \label{chap:Desenoeimplementacion}
% \vspace{0.5cm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Objetivo:                        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \lettrine{E}{n} este capítulo veremos os detalles de deseño e implementación 
de diversas partes do proxecto así como falaremos das decisións tomadas con 
respecto a utilización das tecnoloxías.

  \section{ReactJS e Flux}
    \subsection{Introdución e elección da tecnoloxía}
    Actualmente o mundo das aplicacións móbiles está en pleno crecemento e cada 
vez é máis facil atopar como incluso pequenos comercios ou incluso eventos 
teñen a súa propia aplicación móbil.

    A sociedade está a cambiar un soporte tradicional como é o papel en todas 
os aspectos da vida, dende a publicidade ata a propia xestión e todo estase a 
dixitalizar, facilitando o traballo humano e reducindo os custes a medio prazo.

    Neste contexto decidíuse optar por realizar unha aplicación móbil 
híbrida, con tecnoloxías web, xa que se pode observar un movemento nos últimos 
anos cara este tipo de tecnoloxías que permiten desenvolver únicamente unha 
aplicación e executala nos diversos sistemas operativos móbiles existentes sen 
ter que desenvolver unha aplicación concreta para cada un de eles.

    Tras unha análise das diversas linguaxes e frameworks que podían 
ser utilizados para este fin, finalmente optouse por utilizar ReactJS pola sua 
flexibilidade fronte a outras alternativas como AngularJS ou EmberJS.

    Estas alternativas centranse en ofrecer un framework moi completo buscando 
cubrir todas as tecnoloxías dentro de unha aplicación como o enrutado de urls, 
a internacionalización ou os servizos fronte a React que únicamente trata de 
cubrir a xestión das vistas e do seu estado, dando total liberdade para 
escoller a tecnoloxía que se precise para o resto de compoñentes dunha 
aplicación.

    Así mesmo tamén cómpre destacar a existencia de React Native, unha 
tecnoloxía baseada en React que permite crear aplicacións móbiles con 
tecnoloxías web e con unha experiencia de usuario exactamente igual a unha 
aplicación nativa tradicional.

    Unha vez selecciado React, optamos por seguir a arquitectura máis habitual 
dentro de este tipo de aplicacións, Flux, a través da librería Reflux.

    \subsection{Elementos básicos}
      \subsubsection{Compoñentes de React}
      React é unha librería de Javascript que nos permite xestionar de xeito 
sinxelo as vistas da nosa aplicación a través de diversos elementos denominados 
compoñentes.

      React permítenos escribir os nosos compoñentes con unha sintaxis moi 
similiar a HTML pero posteriormente traduce esta sintaixs a código javascript 
habitual polo que podemos decir que estamos escribindo páxinas web únicamente 
con funcións de javascript.

      A idea principal é reutilizar e agrupar compoñentes para formar o que 
tradicionalmente chamamos vistas e que a súa vez poden ter un estado.
      Este estado pode variar modificando as vistas, como por exemplo, 
engádese un novo gol na lista de eventos e React encárgase de volver a 
renderizar únicamente a parte da vista que cambiou, polo que é tremendamente 
eficiente.

      \subsubsection{Arquitectura Flux}
      Flux é unha arquitectura que básicamente propón o seguinte esquema:

        \begin{figure}[h!]
          \begin{center}
          \includegraphics[width=\textwidth]{./img/flux.png}
          \caption{Esquema da arquitectura Flux}
          \end{center}
        \end{figure}

        \paragraph{Actions}
        A vista atópase formada por unha serie de compoñentes de React que son 
capaces de disparar as Actions, que funcionan de xeito similar a eventos, por 
exemplo ao pulsar un botón e que avisán ao Dispatcher.
        \paragraph{Dispatcher}
        O Dispatcher é o encargado de recibir e enrutar as Actions disparadas 
cara as Stores.
        \paragraph{Stores}
        Estas Stores son as encargadas de xestionar o estado dos compoñentes e 
toda a lóxica necesaria para actualizar o estado co novo cambio.

        Se por exemplo ao pulsar un botón debería cambiar un texto que esa no 
compoñente, poderíamos ter este texto almacenado no estado dentro dunha Store e 
inicializado a un valor baleiro.
        Unha vez se fai click no botón, unha Action chamará a unha Store que é 
a que contén a información sobre cómo cambiar o texto do estado e React 
encargarase de volver a pintar o novo valor do estado, dentro do seu compoñente.

      \subsubsection{Implementación de Flux. Reflux.}
      Flux é unha arquitectura, unha especie de patrón de desenvolvemento pero 
existen diversas implementacións da mesma e neste proxecto decidímonos por 
utilizar Reflux.

      O funcionamento é moi similar pero con algúns matices, por exemplo ao non 
existir un único Dispatcher central que enruta as Actions se non que todas as 
Stores están escoitando e reaccionan cando teñen un método para responder a 
Action.

     Vexamos un exemplo práctico:

     \begin{lstlisting}
      let TextActions = Reflux.createActions([
        "updateText"
      ])
    \end{lstlisting}

    Definiríamos unha Action que queremos lanzar e crearíamos unha Store que 
escoite as TextActions e que implemente unha función onUpdateText que será a 
que reciba o novo valor e actualizará o estado.

     \begin{lstlisting}
        let TextStore = Reflux.createStore({
          listenables: TextActions,
          init: function () {
            this.state = ''
          },
          getInitialState: function () {
            return this.state
          },
          onUpdateText: function (newText) {
            this.state = newText
            this.trigger(this.state)
          }
        })
    \end{lstlisting}

    Por último definir o compoñente. Deberá incluir unha lista de mixins onde 
indicarlle qué Stores reaccionan ante eventos que se lancen dende este 
compoñente, neste caso, a TextStore.

    O compoñente tamén terá un método render no que definir o que poderíamos 
chamar informalmente o ``modelo'' do que queremos renderizar e que inclúe un 
enlace para cambiar o texto mostrado.

    Dito enlace reacciona cando se fai click e chama ao método 
handleChangeTextClick que lanza a Action para que a Store a intercepte, cambie 
o estado e React renderice de novo, únicamente o que cambiou.



     \begin{lstlisting}
      let EndReport = React.createClass({
        mixins: [
          Reflux.connect(TextStore, 'text')
        ],
        handleChangeTextClick: function () {
          TextActions.updateText('Nuevo texto a renderizar')
        }
      render: function () {
          return (
            <p>{this.state}</p>
            <a onClick={this.handleChangeTextClick}>Change text</a>
          )
        }
      })
    \end{lstlisting}


    \subsection{Estructura da aplicación}
    
    \paragraph{App}

      \begin{description}
        \item [Tests] Carpeta onde se poden atopar os tests da aplicación. De 
momento só se dispón de tests da capa de servizos.
        \item [i18n] Nesta localización pódese atopar a internacionalización, 
coas cadeas dentro da subcarpeta de ``messages`` e coa descrición das mesmas 
para cada compoñente de React dentro de ''descriptors`` coa idea de darlle 
contexto e facilitarlle ao traductor a súa labor.
        \item [Cordova app] Aquí podemos atopar a configuración para compilar a 
aplicación aos diversos dispositivios móbiles.
        \item [Src/app] Estructura principal da aplicación
        \begin{description}
          \item [Actions] Lista de ficheiros de accións a disparar agrupados 
cada un pola store que os implementa.
          \item [API] Contén a configuración, as urls da aplicación e a 
factoría utilizada para a inxección de dependencias dos servizos que 
explicaremos máis adiante.
          \item [Components] Lugar onde se poden atopar todos os compoñentes 
que forman as vistas da aplicación. 
          \item [Daos] Entidades que abstraen dos servicios a definición do 
acceso a base de datos, facilitando que sexa sinxelo cambiar dita base de datos 
se é preciso.
          \item [Models] Contén a definición dos modelos da aplicación, tanto as 
entidades que se almacenan en base de datos como de cercas clases que son 
utilizadas pola aplicación como as que definen os deportes ou a implementación 
dos tipos de eventos.
          \item [Services] Estas clases conteñen a lóxica de negocio da 
aplicación.
          \item [Stores] Lista de ficheiros que conteñen e xestionan o estado da 
aplicación diferenciando a lóxica de negocio, que se almacena nos servizos, da 
xestión do estado dos compoñentes de React.
          \item [app.js] Ficheiro de inicialización da aplicación que se encarga 
de arrancar o enrutador e executa a aplicación ben en modo web ou ben en modo 
aplicación móbil en función da configuración definida.
          \item [router.jsx] É o encargado de poñer en relación as urls da 
aplicación cos compoñentes que corresponden a cada unha e donde se introduce 
tamén a información sobre a internacionalización.

        \end{description}

      \end{description}


  \section{Bases de datos e funcionamento offline}
  O mundo das bases de datos está a cambiar enormemente nos últimos anos coa 
aparición das bases de datos non relacionáis, neste caso concreto, era preciso 
dispoñer de unha base de datos no cliente que permitise almacenar os 
datos das actas dos encontros de forma offline xa que o árbitro do encontro 
pode non ter cobertura e debería poder cubrir a súa acta da mesma forma.

  Ante este requisito cabe pensar nas bases de datos lixeiras como SQLite que 
se utilizan habitualmente nas aplicacións móbiles pero ditas bases de datos non 
poden ser executadas directamente nun navegador web, polo que finalmente se 
optóu por utilizar PouchDB, unha base de datos orientada a documentos e creada 
sobre o LocalStorage do navegador, pensada dende o primeiro momento para 
crear aplicacións web que funcionen de forma desconectada.

    \subsection{PouchDB}
    As actas electrónicas son documentos que unha vez sexan creadas, apenas 
serán modificadas e neste tipo de datos son as bases de datos orientadas a 
documentos as que mellor funcionan.

    A elección de PouchDB foi sobre todo motivada polas súas características de 
ser lixeira, multinavegador e sobre todo, facilitar a sincronización contra 
unha base de datos remota, neste caso, CouchDB.

    \subsection{CouchDB}
    CouchDB é a base de datos non relacional que se utiliza como base de datos 
central en remoto coa cal sincronizará a PouchDB que se atopa na aplicación que 
utilizará o árbitro.

    Esta base de datos é tremendamente versatil e sinxela de utilizar xa que 
implementa unha API REST e a forma de interactuar con ela basease simplemente 
en enviar documentos JSON a través de sinxelas peticións HTTP cara a súa API.

    Destaca pola súa extensa comunidade e por ser altamente dispoñible e 
tolerante a erros pero eventualmente inconsistente pero sobre todo pola súa 
xestión de conflictos que comentamos a continuación.

    \subsection{Sincronización e xestión de conflictos}
    Probablemente o maior reto a hora de enfrentarse a unha aplicación con 
funcionamento offline é a xestión de conflictos entre os datos.

    En este caso en concreto, existe a problemática de que por múltiples 
motivos, un acta sexa modificada en dous lugares ao mesmo tempo, tanto polo 
árbitro no seu teléfono como pola persoa encargada da xestión da federación 
polo que resulta imprescindible non perder información e ser capaces de 
mostrarlle a totalidade da información ao xestor da federación para que este 
poida seleccionar cales datos son os reais.

    Neste punto é donde CouchDB resulta moi útil xa que a propia base de datos 
se encarga de almacenar un árbol co histórico de revisións que se producen 
sobre un documento e así se poderían mostrar ao usuario para que seleccione a 
correcta en caso de conflicto.

  \section{App híbrida con Apache Cordova}
  O obxectivo do proxecto é poder utilizalo en múltiples dispositivos móbiles 
co fin de facilitar que calquera árbitro poida utilizala independentemente do 
sistema operativo que teña o seu teléfono ou tableta.

  É por isto que é fundamental a utilización dun sistema que permita este 
desenvolvemento multiplataforma como é o caso de Apache Cordova que facilita o 
acceso aos elementos do dispositivo como sensores, datos, estado de rede... a 
través dunha serie de APIs estandar.

  Actualmente non se está a utilizar ningunha de estas funcionalidades pero si 
é posible que nun futuro cercano se decidan implementar novas características 
que si precise o acceso a este tipo de elementos como pode ser por exemplo o 
micrófono para que o árbitro poida gardar as incidencias dun partido como notas 
de voz en lugar de escribilas.

  A continuación podemos ver un esquema sobre a arquitectura dunha aplicación 
sobre Apache Córdova:

    \begin{figure}[h!]
      \begin{center}
      \includegraphics[width=0.8\textwidth]{./img/cordova_arquitectura.png}
      \caption{Arquitectura de unha aplicación con Apache Cordova}
      \end{center}
    \end{figure}

  Básicamente a aplicación executase como unha aplicación web normal sobre un 
WebView, un motor de renderizado de HTML que pode interactuar coas APIs nativas 
do dispositivo a través dunha serie de plugins que Cordova provee.

  Para executar a aplicación únicamente é preciso crear un proxecto de Cordova, 
engadir os ficheiros da aplicación, as plataformas para as que se desexe xerar 
o proxecto e construilo.

  \section{Interface gráfica e usabilidade}
  Estructura a nivel de deseño da aplicación. Reutilización de compoñentes xenéricos.

    \subsection{Elementos comúns}

      \subsubsection{Menú lateral esquerdo}
      Cómo se estructura e se engaden novos elementos.

      \subsubsection{Enlaces do menu superior dereito}
      Cómo se estructura e se engaden novos.

      \subsubsection{Información e axustes}

      \subsubsection{SnackBar}
      Para xestión de erros

    \subsection{Listado de actas}


    \subsection{Acta}
      Falar do campo primario e secundario.

      \subsubsection{Convocar xogadores}

      \subsubsection{Inicio e fin do partido}
      Non se poden engadir eventos ata o de inicio pero si despois do fin...

      \subsubsection{Cronómetro}

      \subsubsection{Tipos de eventos}
    Control o de deporte
      \paragraph{Eventos de control}
      \paragraph{Eventos de deporte}
        \subparagraph{Eventos de puntuación (Score events)}
        Que actualizan tamén a acta e o estado da aplicación.

    \subsection{Finalización do encontro}

      \subsubsection{Incidencias}

      \subsubsection{Sinatura con PIN}

  \section{Multideporte}
  Un dos obxectivos iniciais era conseguir que a aplicación puidera adaptarse 
de xeito moi sinxelo a novos deportes, inicialmente comezaríase co fútbol pero 
todo o deseño debía estar orientado cara este finalidade.

  \subsection{Deporte}
  Para iso creouse unha Store que contén a información do deporte que a 
aplicación está xestionando actualmente e que pode ser actualizado e cambiado 
por outro de xeito moi sinxelo.

  Por outro lado, cada deporte debe extender a unha clase xenérica Sport que 
define unha serie de métodos que todos os deportes deben implementar e que 
definen como se realizan certas accións sobre os datos en cada deporte.

  \begin{description}
   \item [Eventos] A lista de eventos que se poden realizar en ese deporte.
   \item [Evento por tipo] Que permite recuperar un obxecto Evento a partir da 
clave do seu tipo.
   \item [Icono por tipo] Que devolve o icono que identifica un Evento de un 
tipo para renderizalo en algunha parte da aplicación como a lista de eventos.
   \item [Campo primario] É unha función que calcula o resultado para 
almacenar no campo primario da acta en función da lista de eventos para ese 
encontro e de cada deporte. En fútbol devolve únicamente a suma de eventos de 
tipo gol.
   \item [Campo secundario] Similar ao campo anterior pero para introducir 
información no campo secundario da acta, no caso do fútbol, no campo secundario 
almacena as faltas do encontro e esta función devolve a suma de faltas que hay 
no partido.
  \end{description}

  Esta implementación fai que sexa tremendamente sinxelo engadir un novo 
deporte, básicamente sería crear unha nova clase que extendese os métodos 
correspondentes coa funcionalidade concreta de ese deporte.

  \subsection{Eventos}
  Do mesmo xeito, cada deporte ten os seus propios eventos polo que se definíu 
unha forma de engadir eventos de xeito sinxelo, co fin de que a incorporación 
de un novo deporte resultase o máis trivial posible.

  Actualmente podemos dividir os eventos en dóus tipos:

  \begin{description}
    \item [De control] Son eventos xenéricos de xestión como cambiar de parte, 
ou comezar un encontro que non é habitual que vaian a cambiar xa que son 
habitualmente os mesmos en todos os deportes.
    \item [De deporte] Son eventos concretos de cada deporte como engadir un gol 
ou unha tarxeta e que dispoñen, a súa vez divídense en:
      \begin{description}
       \item [Evento] É un tipo de evento de deporte que únicamente permite ser 
engadido ou eliminado, non dispón de un comportamento especial.
       \item [Evento con causa] Ese tipo de evento engade tamén unha causa aos 
eventos xa que é habitual que se precise indicar o motivo polo que se producíu 
un evento como por exemplo cando o árbitro expulsa a un xogador con unha 
tarxeta vermella.
      \end{description}

  \end{description}

  Existe un compoñente de React para incorporar os eventos de control dentro 
da vista que lista os eventos dun partido e que calquera evento de este tipo, 
definindo unha clase como a establecida para os eventos de control cos detalles 
do seu funcionamento, pode utilizar.
\todo{engadir imaxe de exemplo}

  Por outra banda temos tamén un compoñente de React para introducir os eventos 
deportivos na lista de eventos dun partido e cada evento novo debe crear un 
novo compoñente que defina a vista a mostrar cando se desexe engadir un evento 
de este tipo no encontro.

  En definitiva, para crear un novo evento débese definir unha clase Javascript 
coas propiedades do mesmo e que extenda ao SportEvent.

  Tamén é preciso engadir unha clase de React que defina a vista que se 
mostrará ao intentar engadir o evento durante o encontro (habitualmente unha 
ventá modal) e por último débese engadir o evento creado anteriormente, dentro 
da lista de eventos que ten ese deporte e que se atopan na clase que define as 
propiedades de dito deporte.

  \section{Deseño da DB}
  VACmatch Mobile estaba pensado inicialmente para integrarse co sistema de 
xestión de competicións que estamos a desenvolver con VACmatch Web que dispón 
dunha API de comunicacións que se atopa montada sobre unha base de datos 
relacional.

  É por iso que o modelo de datos estába pensado para unha base de 
datos relacional e tivo que ser adaptado para utilizar unha non relacional 
orientada a documentos.

  Prácticamente todas as entidades foron desnormalizadas para incluir 
información necesaria e en algún caso comprimironse dúas entidades en unha soa 
como é o caso de Call e Member que foron unidas dentro de Person como se indica 
no gráfico seguinte.

    \begin{figure}[h!]
      \begin{center}
      \includegraphics[width=0.2\textwidth]{./img/cordova_arquitectura.png}
      \caption{Esquema base de datos de Person.}
      \end{center}
    \end{figure}

  \section{I18n}
  Para a xestión da internacionalización da aplicación utilizouse a librería 
React Intl que provee unha serie de compoñentes de React e unha API sinxela 
para formatear datas, números e strings, incluindo pluralización e xestión de 
traduccións.

  Esta librería da a posibilidade de engadir un contexto aos textos que se 
internacionalizan o cal facilitará a labor do traductor que se encargue de 
engadir ou modificar un idioma, proveendo dunha información extra sobre o texto 
que debe traducir.

  Únicamente é preciso definir os compoñentes cos seus correspondentes 
atributos como se mostra no código seguinte e a propia ferramenta xenera 
ficheiros .json seguindo o esquema de carpetas e ficheiros da aplicación con 
toca a información recopilada.

     \begin{lstlisting}[caption=Exemplo de internacionalización na label de un 
botón.]
        <RaisedButton label={
            <FormattedMessage
                id='report.show.events'
                description='Events button'
                defaultMessage='Events'/>
        } secondary={true} style={style.button}/>
    \end{lstlisting}

  Do mesmo xeito, a librería permite facer internacionalización de xeito 
programático sen utilizar compoñentes de react, a través de unha serie de 
funcións de javascript.

  Ademáis é preciso realizar as traduccións aos diferentes idiomas, cada un 
en un ficheiro de javascript diferente e con un formatado de pares cadea/valor.

  \section{Inxección de dependencias}
  Durante o realización do proxecto xurdíu problema entre os servizos xa que 
moitos precisan dos outros para realizar comprobacións de forma circular.

  A existencia destas dependencias circulares leva a que sexa imposible 
determinar a relación entre eles polo que é preciso deseñar un pequeno sistema 
de inxección de dependencias.

  A solución tomada é moi similiar a implementación que realiza Spring, 
dispoñemos dunha factoría que se encarga de crear un obxecto para cada servizo 
e a continuación inxéctanse uns dentro dos outros.

  Cada vez que se chama a factoría para recuperar un servizo, a factoría 
devolve o servizo coas súas dependencias inxectadas no seu interior polo que 
resolvemos o problema de xeito sinxelo.

  A continuación pódese ver un exemplo da factoría que se encarga de crear os 
servizos:

       \begin{lstlisting}[caption=Exemplo de internacionalización na label de 
un botón.]

let ServiceFactory = {
  isInitialized: false,
  _servicesList: new Map(),

  constructor () {
    this._personService = new PersonService()
    this._reportService = new ReportService()
    this._refereeService = new RefereeService()
    // Without dependencies
    this._teamService = new TeamService()
    // Inject dependencies
    this._eventService.ReportService = this._reportService
    this._eventService.PersonService = this._personService
    this._eventService.TeamService = this._teamService
    ...
    // Add services to the exposed list
    this._servicesList.set('ReportService', this._reportService)
    this._servicesList.set('PersonService', this._personService)
    this._servicesList.set('TeamService', this._teamService)
    this.isInitialized = true
  },

  getService  (type) {
    if (!this.isInitialized) {
      this.constructor()
    }
    let service = this._servicesList.get(type)
    if (!service) {
      console.log('Error getting ', type, ' service')
    }
    return service
  }

}
    \end{lstlisting}

  Cómpre tamén comentar as dificultades que implica a inxección de dependencias 
ao realizar testing unitario xa que non se poden aproveitar as funcionalidades 
que aporta Jest, o framework de testing, que permiten automatizar a creación de 
mocks e obriga a crear manualmente os mocks dos servizos e inxectalos dentro do 
servicio a testear en cada test.

  \section{Testing e Integración continua}
  O testing é unha parte fundamental nun proxecto e concretamente nun proxecto 
de software libre no que a comunidade pode colaborar e onde poden 
participar persoas sen un coñecemento moi profundo da aplicación, polo que se 
fai totalmente imprescindible garantizar que calquera cambio non rompa a 
integridade da aplicación.

    \subsection{TDD e BDD}
  Neste proxecto seguironse diversas prácticas de Test Driven Development 
(TDD) e Behaviour Driven Development (BDD) comezando por unha definición das 
diversas tarefas do proxecto como tests de aceptación das funcionalidades e 
rematando pola realización de tests unitarios.

      \paragraph{Tests de aceptación} Estos tests son destinados a determinar 
se foron cumplidos os requisitos de unha certa funcionalidade, sempre 
centrándose na parte funcional e alonxándose dos detalles de implementación.

      Para isto utilízanse unha linguaxe simple de dominio para definir os 
requisitos funcionáis, en este proxecto baseamonos no seguinte:

        \begin{description}
         \item [Como ....] afectado ou realizador da funcionalidade.
         \item [Quero ...] acción a realizar.
         \item [Cando ...] momento ou caso no que debe realizarse.
        \end{description}

        Un exemplo de test de aceptación:

        \emph{Como árbitro quero que o resultado se actualice automáticamente 
ao engadir un novo gol}.

      \paragraph{Tests unitarios} Estos tests centranse en comprobar o 
funcionamento de xeito aislado dos diversos sistemas e centrándose en que cada 
proba sexa un caso totalmente independente do resto.

      En este proxecto crearonse tests unitarios centrados nos servizos da 
aplicación, que son os elementos máis importantes da mesma xa que son os que 
definen a lóxica de negocio.

      Para a realización de este tipo de tests é fundamental a utilización de 
mocks, obxectos que imitan o comportamento de obxectos reais de xeito 
controlado o cal permite simular o comportamento dos obxectos dependentes.
      Esto é fundamental para asegurar o illamento da funcionalidade e eliminar 
a dependencia de outros elementos a hora de realizar as probas unitarias.

    \subsection{Jest}
    É unha librería para realización de testing automático en aplicacións 
ReactJS que facilita.

    A continuación móstrase un test de exemplo do módulo de eventos no que se 
pode observar os compoñentes que o forman.

    Inicialmente defínese dentro da sección ''describe`` unha ''historia de 
usuario`` que contén a información xeral sobre o caso de uso, dentro da cal 
pódense realizar diversos tests, no exemplo que vemos, o caso de uso é ''Crear 
un evento deportivo''.

    Dentro do caso de uso vemos un bloque ``beforeEach'' que permite 
inicializar variables para cada novo test que se realice, eliminando de este 
xeito a dependencia entre os tests das variables que utilizan.

    Dentro do bloque ``describe'' defínense os diversos tests de esta historia 
de usuario dentro dos bloques ``it''.

    Ao realizar tests unitarios é habitual a utilización de obxectos mock que 
imitan a funcionalidade de outros.

    En Jest todos os obxectos son mocks e non é preciso definilos todos así, 
cambiando un pouco a forma de traballar habitualmente, aquí débese definir ao 
comezo do ficheiro aqueles que non van a ser mockeados a través da 
seguinte sentencia:

    \begin{lstlisting}
     jest.dontMock('../../src/app/models/report/status/StartedStatus')
    \end{lstlisting}

    Tamén é habitual querer darlle un comportamento por defecto aos mocks que 
se utilizan, por exemplo no seguinte trozo de código estamos facendo que cando 
se chame a función ``findById'' do obxecto ``reportService''  co un só 
parámetro, que o obxecto devolva un callback cos parámetros indicados, neste 
caso unha Acta por defecto (defaultReport) e un valor nulo como segundo 
parámetro.

    \begin{lstlisting}
spyOn(reportService, 'findById').andCallFake(function (anyReportId, callback) {
  callback(defaultReport, null)
})
    \end{lstlisting}

    Unha vez definido o comportamento que queremos que teñan os mocks, debemos 
chamar ao método real do obxecto que estamos testeando e así teremos totalmente 
illado o comportamento do método a testear

    Finalmente utilizamos a cláusula ``expect'' para indicar resultados 
esperados, no caso de exemplo que mostramos a continuación, estamos a indicar 
que a chamada ao método findById de reportService foi realizada pero tamén é 
posible indicar valores que debe devolver, negacións ou outras validacións 
incluso máis complexas.

    \begin{lstlisting}
      expect(reportService.findById).toHaveBeenCalled()
    \end{lstlisting}

    A continuación mostramos o caso de test anterior completo a modo de exemplo.

    \begin{lstlisting}[caption=Exemplo de test no módulo e eventos utilizando 
Jest.]
      describe('create Sport Event', function () {

        beforeEach(function () {
          defaultPerson = new Person(null, '', '', '', '', false, false, '', 
'',   '')
          defaultTeam = new Team(null, 'Team name')
          defaultReport = new Report(null, '', '', ReportStatus.READY, 
defaultTeam, defaultTeam, [])
          defaultEvent = new EventElements.Event('event', '1', defaultPerson, 
      defaultTeam, 'goal', 1, 'cause', 1)
          reportService = new ReportService(jasmine.createSpy('PersonService'), 
      jasmine.createSpy('TeamService'), jasmine.createSpy('EventService'), 
      jasmine.createSpy('SignService'))
          personService = new PersonService(jasmine.createSpy('ReportService'), 
      jasmine.createSpy('TeamService'), jasmine.createSpy('AuthService'))
          teamService = new TeamService()
          eventService = new EventService(reportService, personService, 
  teamService)
        })

        it('Create a new Sport Event with valid parameters', function () {

          spyOn(reportService, 'findById').andCallFake(function (anyReportId, 
      callback) {
            callback(defaultReport, null)
          })

          spyOn(personService, 
    'findByPersonIdReportIdAndTeamId').andCallFake(function   (anyPersonId, 
    anyReportId, anyTeamId, callback) {
            callback(defaultPerson, null)
          })

          spyOn(teamService, 'findById').andCallFake(function (anyTeamId, 
  callback)  {
            callback(defaultTeam, null)
          })

          spyOn(EventDao, 'create').andCallFake(function (reportId, person, 
team, eventType, matchTime, cause, timestamp, callback) {
            callback(defaultEvent, null)
          })

          eventService.create(defaultEvent.reportId, defaultEvent.person, 
      defaultEvent.team,
            defaultEvent.type, defaultEvent.matchTime, defaultEvent.text, 
      defaultEvent.timestamp,
            (event, err) => {
              expect(event).toEqual(defaultEvent)
              expect(event).not.toBe(null)
              expect(err).toBe(null)
          })

          expect(reportService.findById).toHaveBeenCalled()
          
expect(personService.findByPersonIdReportIdAndTeamId).toHaveBeenCalled()
          expect(teamService.findById).toHaveBeenCalled()
          expect(EventDao.create).toHaveBeenCalled()
        })
  \end{lstlisting}[

    \subsection{Travis CI}
    A medida que a aplicación foi medrando, xurdíu a necesidade de simplificar 
traballos como a búsqueda de erros ou o mantemento da aplicación, buscando 
garantizar que se mantén a integridade da mesma en todo momento e non se 
introducen erros polo que se decidíu engadir tests unitarios na aplicación.

    Da mesma maneira lanzóuse unha primeira vesión estable do proxecto polo 
que tamén se decidíu engadir un sistema de integración continua ao mesmo co 
fin de garantizar que a aplicación xerada na rama de producción é funcional, 
compila en todo momento e pasa tódolos tests.

    Para isto utilizóuse Travis CI como sistema integración para o que se 
engadíu un ficheiro ``.travis.yml'' no que se lle indica a Travis diversos 
parámetros de configuración como as versións de Javascript coas que debe poñer 
a proba o funcionamento do programa, os scripts a executar para instalar 
dependencias e executar o programa, as ramas de desenvolvemento sobre as que 
debe actuar, no noso caso ``master'' e ``development`` ou as notificacións que 
debe enviar ao finalizar un traballo como por correo electrónico ou utilizando 
un servizo de mensaxería instantánea como Slack.

    Nesta integración xurdíu un problema derivado do sistema de construcción 
utilizado no proxecto, Gulp, que nos axuda a automatizar tarefas como a 
compilación, a execución dos tests ou o deploy da aplicación, e do framework de 
tests, Jest xa que a execución de este último a través de Gulp non devolvía os 
erros ao resolver os tests como resultado da función se non que o facía a 
través de un callback polo que foi preciso engadir na tarefa ''test`` definida 
en Gulp, o control de este caso para evitar falsos positivos na execución dende 
Travis.
